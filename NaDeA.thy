theory NaDeA imports Main begin                                                                     (*  Isabelle theory file (Isabelle2020)                                       *)
                                                                                                    (*                                                                            *)
type_synonym id = "char list"                                                                       (*  A function/predicate identifier is a list of characters.                  *)
                                                                                                    (*                                                                            *)
datatype tm = Var nat | Fun id "tm list"                                                            (*  Variables are enumerated by natural numbers (de Bruijn indices).          *)
                                                                                                    (*                                                                            *)
datatype fm = Falsity | Pre id "tm list" | Imp fm fm | Dis fm fm | Con fm fm | Exi fm | Uni fm      (*  The formula classes. There is no negation or bi-implication.              *)
                                                                                                    (*                                                                            *)
primrec                                                                                             (*                                                                            *)
  semantics_term :: "(nat => 'a) => (id => 'a list => 'a) => tm => 'a"                              (*  Semantics of terms are values in the universe. The type is arbitrary.     *)
and                                                                                                 (*                                                                            *)
  semantics_list :: "(nat => 'a) => (id => 'a list => 'a) => tm list => 'a list"                    (*  Semantics of lists (of terms) are lists of values in the universe.        *)
where                                                                                               (*                                                                            *)
  "semantics_term e f (Var n) = e n" |                                                              (*  Values of variables are obtained by look up in the variable environment.  *)
  "semantics_term e f (Fun i l) = f i (semantics_list e f l)" |                                     (*  Functions are looked up in the function environment.                      *)
  "semantics_list e f [] = []" |                                                                    (*  List semantics: List of semantic values of terms.                         *)
  "semantics_list e f (t # l) = semantics_term e f t # semantics_list e f l"                        (*                                                                            *)
                                                                                                    (*                                                                            *)
primrec                                                                                             (*                                                                            *)
  semantics :: "(nat => 'a) => (id => 'a list => 'a) => (id => 'a list => bool) => fm => bool"      (*  Semantics give truth values to formulas. Takes a variable environment,    *)
where                                                                                               (*  a function environment, predicate environment, and a formula.             *)
  "semantics e f g Falsity = False" |                                                               (*                                                                            *)
  "semantics e f g (Pre i l) = g i (semantics_list e f l)" |                                        (*                                                                            *)
  "semantics e f g (Imp p q) = (if semantics e f g p then semantics e f g q else True)" |           (*                                                                            *)
  "semantics e f g (Dis p q) = (if semantics e f g p then True else semantics e f g q)" |           (*                                                                            *)
  "semantics e f g (Con p q) = (if semantics e f g p then semantics e f g q else False)" |          (*                                                                            *)
  "semantics e f g (Exi p) = (? x. semantics (% n. if n = 0 then x else e (n - 1)) f g p)" |        (*  ? is for existential quantification. % is for lambda abstraction.         *)
  "semantics e f g (Uni p) = (! x. semantics (% n. if n = 0 then x else e (n - 1)) f g p)"          (*  ! is for universal quantification.                                        *)
                                                                                                    (*                                                                            *)
primrec                                                                                             (*                                                                            *)
  member :: "fm => fm list => bool"                                                                 (*  member: Determines if a formula is contained in a list of formulas.       *)
where                                                                                               (*                                                                            *)
  "member p [] = False" |                                                                           (*                                                                            *)
  "member p (q # z) = (if p = q then True else member p z)"                                         (*                                                                            *)
                                                                                                    (*                                                                            *)
primrec                                                                                             (*                                                                            *)
  new_term :: "id => tm => bool"                                                                    (*  new_term: Determines if the identifier is new in the term.                *)
and                                                                                                 (*                                                                            *)
  new_list :: "id => tm list => bool"                                                               (*  new_list: Determines if the identifier is new in the list of terms.       *)
where                                                                                               (*                                                                            *)
  "new_term c (Var n) = True" |                                                                     (*                                                                            *)
  "new_term c (Fun i l) = (if i = c then False else new_list c l)" |                                (*                                                                            *)
  "new_list c [] = True" |                                                                          (*                                                                            *)
  "new_list c (t # l) = (if new_term c t then new_list c l else False)"                             (*                                                                            *)
                                                                                                    (*                                                                            *)
primrec                                                                                             (*                                                                            *)
  new :: "id => fm => bool"                                                                         (*  new: Determines if the identifier is new in the formula.                  *)
where                                                                                               (*                                                                            *)
  "new c Falsity = True" |                                                                          (*                                                                            *)
  "new c (Pre i l) = new_list c l" |                                                                (*                                                                            *)
  "new c (Imp p q) = (if new c p then new c q else False)" |                                        (*                                                                            *)
  "new c (Dis p q) = (if new c p then new c q else False)" |                                        (*                                                                            *)
  "new c (Con p q) = (if new c p then new c q else False)" |                                        (*                                                                            *)
  "new c (Exi p) = new c p" |                                                                       (*                                                                            *)
  "new c (Uni p) = new c p"                                                                         (*                                                                            *)
                                                                                                    (*                                                                            *)
primrec                                                                                             (*                                                                            *)
  news :: "id => fm list => bool"                                                                   (*  news: Determines if the identifier is new the list of formulas.           *)
where                                                                                               (*                                                                            *)
  "news c [] = True" |                                                                              (*                                                                            *)
  "news c (p # z) = (if new c p then news c z else False)"                                          (*                                                                            *)
                                                                                                    (*                                                                            *)
primrec                                                                                             (*                                                                            *)
  inc_term :: "tm => tm"                                                                            (*                                                                            *)
and                                                                                                 (*                                                                            *)
  inc_list :: "tm list => tm list"                                                                  (*                                                                            *)
where                                                                                               (*                                                                            *)
  "inc_term (Var n) = Var (n + 1)" |                                                                (*                                                                            *)
  "inc_term (Fun i l) = Fun i (inc_list l)" |                                                       (*                                                                            *)
  "inc_list [] = []" |                                                                              (*                                                                            *)
  "inc_list (t # l) = inc_term t # inc_list l"                                                      (*                                                                            *)
                                                                                                    (*                                                                            *)
primrec                                                                                             (*                                                                            *)
  sub_term :: "nat => tm => tm => tm"                                                               (*  sub_term: Substitutes a variable in the term with a given term.           *)
and                                                                                                 (*                                                                            *)
  sub_list :: "nat => tm => tm list => tm list"                                                     (*  sub_list: Substitutes a variable in the term list with a given term.      *)
where                                                                                               (*                                                                            *)
  "sub_term v s (Var n) = (if n < v then Var n else if n = v then s else Var (n - 1))" |            (*                                                                            *)
  "sub_term v s (Fun i l) = Fun i (sub_list v s l)" |                                               (*                                                                            *)
  "sub_list v s [] = []" |                                                                          (*                                                                            *)
  "sub_list v s (t # l) = sub_term v s t # sub_list v s l"                                          (*                                                                            *)
                                                                                                    (*                                                                            *)
primrec                                                                                             (*                                                                            *)
  sub :: "nat => tm => fm => fm"                                                                    (*  sub: Substitutes a variable in the formula with a given term.             *)
where                                                                                               (*                                                                            *)
  "sub v s Falsity = Falsity" |                                                                     (*                                                                            *)
  "sub v s (Pre i l) = Pre i (sub_list v s l)" |                                                    (*                                                                            *)
  "sub v s (Imp p q) = Imp (sub v s p) (sub v s q)" |                                               (*                                                                            *)
  "sub v s (Dis p q) = Dis (sub v s p) (sub v s q)" |                                               (*                                                                            *)
  "sub v s (Con p q) = Con (sub v s p) (sub v s q)" |                                               (*                                                                            *)
  "sub v s (Exi p) = Exi (sub (v + 1) (inc_term s) p)" |                                            (*                                                                            *)
  "sub v s (Uni p) = Uni (sub (v + 1) (inc_term s) p)"                                              (*                                                                            *)
                                                                                                    (*                                                                            *)
inductive                                                                                           (*                                                                            *)
  OK :: "fm => fm list => bool"                                                                     (*  OK: Inductive definition of proof rules.                                  *)
where                                                                                               (*                                                                            *)
Assume:                                                                                             (*                                                                            *)
        "member p z ==> OK p z" |                                                                   (*                                                                            *)
Boole:                                                                                              (*                                                                            *)
        "OK Falsity ((Imp p Falsity) # z) ==> OK p z" |                                             (*                                                                            *)
Imp_E:                                                                                              (*                                                                            *)
        "OK (Imp p q) z ==> OK p z ==> OK q z" |                                                    (*                                                                            *)
Imp_I:                                                                                              (*                                                                            *)
        "OK q (p # z) ==> OK (Imp p q) z" |                                                         (*                                                                            *)
Dis_E:                                                                                              (*                                                                            *)
        "OK (Dis p q) z ==> OK r (p # z) ==> OK r (q # z) ==> OK r z" |                             (*                                                                            *)
Dis_I1:                                                                                             (*                                                                            *)
        "OK p z ==> OK (Dis p q) z" |                                                               (*                                                                            *)
Dis_I2:                                                                                             (*                                                                            *)
        "OK q z ==> OK (Dis p q) z" |                                                               (*                                                                            *)
Con_E1:                                                                                             (*                                                                            *)
        "OK (Con p q) z ==> OK p z" |                                                               (*                                                                            *)
Con_E2:                                                                                             (*                                                                            *)
        "OK (Con p q) z ==> OK q z" |                                                               (*                                                                            *)
Con_I:                                                                                              (*                                                                            *)
        "OK p z ==> OK q z ==> OK (Con p q) z" |                                                    (*                                                                            *)
Exi_E:                                                                                              (*                                                                            *)
        "OK (Exi p) z ==> OK q ((sub 0 (Fun c []) p) # z) ==> news c (p # q # z) ==> OK q z" |      (*  "sub 0 (Fun c []) p" substitutes variables with de Bruijn index 0         *)
Exi_I:                                                                                              (*  for a new (fresh) constant c. Newness ensured by "news" statement.        *)
        "OK (sub 0 t p) z ==> OK (Exi p) z" |                                                       (*                                                                            *)
Uni_E:                                                                                              (*                                                                            *)
        "OK (Uni p) z ==> OK (sub 0 t p) z" |                                                       (*                                                                            *)
Uni_I:                                                                                              (*                                                                            *)
        "OK (sub 0 (Fun c []) p) z ==> news c (p # z) ==> OK (Uni p) z"                             (*                                                                            *)
                                                                                                    (*                                                                            *)
lemma "OK (Imp (Pre ''A'' []) (Pre ''A'' [])) []" proof (rule Imp_I, rule Assume, simp) qed         (*  Formula "A --> A" example but not declarative style...                    *)
                                                                                                    (*                                                                            *)
lemma "OK (Imp (Pre ''A'' []) (Pre ''A'' [])) []"                                                   (*  Formula "A --> A" example.                                                *)
proof -                                                                                             (*  Note "-" to start from nothing.                                           *)
  have "OK (Pre ''A'' []) [(Pre ''A'' [])]" proof (rule Assume) qed simp                            (*                                                                            *)
  then show "OK (Imp (Pre ''A'' []) (Pre ''A'' [])) []" proof (rule Imp_I) qed                      (*                                                                            *)
qed                                                                                                 (*                                                                            *)
                                                                                                    (*                                                                            *)
fun                                                                                                 (*                                                                            *)
  put :: "(nat => 'a) => nat => 'a => nat => 'a"                                                    (*  put: Inserts a value in the environment at a given index.                 *)
where                                                                                               (*       Existing values with equal/higher index are shifted to the right.    *)
  "put e v x = (% n. if n < v then e n else if n = v then x else e (n - 1))"                        (*                                                                            *)
                                                                                                    (*                                                                            *)
lemma "put e 0 x = (% n. if n = 0 then x else e (n - 1))" proof simp qed                            (*  Lemma: Applying "put" to index 0 removes the need for else-if construct.  *)
                                                                                                    (*                                                                            *)
lemma increment:                                                                                    (*                                                                            *)
  "semantics_term (put e 0 x) f (inc_term t) = semantics_term e f t"                                (*  The semantic of a term (or list) is unchanged if we put a new variable    *)
  "semantics_list (put e 0 x) f (inc_list l) = semantics_list e f l"                                (*  value into the environment at index 0 and increment the variables         *)
proof (induct t and l rule: semantics_term.induct semantics_list.induct) qed simp_all               (*  occurring inside the term.                                                *)
                                                                                                    (*                                                                            *)
lemma commute: "put (put e v x) 0 y = put (put e 0 y) (v + 1) x" proof force qed                    (*  Lemma: The order of nested "put" commutes as long as you use              *)
                                                                                                    (*         the correct indexation.                                            *)
fun                                                                                                 (*                                                                            *)
  all :: "(fm => bool) => fm list => bool"                                                          (*  all: Checks if "b p" holds for all formulas p in the list.                *)
where                                                                                               (*                                                                            *)
  "all b z = (! p. if member p z then b p else True)"                                               (*                                                                            *)
                                                                                                    (*                                                                            *)
lemma allhead: "all b (p # z) ==> b p" proof simp qed                                               (*  "all" holds for head of list.                                             *)
                                                                                                    (*                                                                            *)
lemma alltail: "all b (p # z) ==> all b z" proof simp qed                                           (*  "all" holds for tail of list.                                             *)
                                                                                                    (*                                                                            *)
lemma allnew: "all (new c) z = news c z" proof (induct z) qed (simp, simp, metis)                   (*  "all new" corresponds to "news".                                          *)
                                                                                                    (*                                                                            *)
lemma map':                                                                                         (*  map': Mapping c to a different value does not change the                  *)
  "new_term c t ==> semantics_term e (f(c := m)) t = semantics_term e f t"                          (*        semantic value of the term/list that it is new in.                  *)
  "new_list c l ==> semantics_list e (f(c := m)) l = semantics_list e f l"                          (*                                                                            *)
proof (induct t and l rule: semantics_term.induct semantics_list.induct)                            (*                                                                            *)
qed (simp, simp, metis, simp, simp, metis)                                                          (*                                                                            *)
                                                                                                    (*                                                                            *)
lemma map: "new c p ==> semantics e (f(c := m)) g p = semantics e f g p"                            (*  map: The property of "map'" for terms/lists also holds for a formula,     *)
proof (induct p arbitrary: e)                                                                       (*       when the value c is new in the formula.                              *)
qed (simp, simp, metis map'(2), simp, metis, simp, metis, simp, metis, simp_all)                    (*                                                                            *)
                                                                                                    (*                                                                            *)
lemma allmap: "news c z ==> all (semantics e (f(c := m)) g) z = all (semantics e f g) z"            (*  allmap: "map" extended to list of formulas.                               *)
proof (induct z) qed (simp, simp, metis map)                                                        (*                                                                            *)
                                                                                                    (*                                                                            *)
lemma substitute':                                                                                  (*                                                                            *)
  "semantics_term e f (sub_term v s t) = semantics_term (put e v (semantics_term e f s)) f t"       (*  substitute': Substituting a variable in a term/list corresponds           *)
  "semantics_list e f (sub_list v s l) = semantics_list (put e v (semantics_term e f s)) f l"       (*               semantically to updating the value of the variable           *)
proof (induct t and l rule: semantics_term.induct semantics_list.induct) qed simp_all               (*               in the environment.                                          *)
                                                                                                    (*                                                                            *)
lemma substitute: "semantics e f g (sub v t p) = semantics (put e v (semantics_term e f t)) f g p"  (*  substitute: "substitute'" generalized to hold for formulas.               *)
proof (induct p arbitrary: e v t)                                                                   (*                                                                            *)
  fix i l e v t                                                                                     (*                                                                            *)
  show "semantics e f g (sub v t (Pre i l)) = semantics (put e v (semantics_term e f t)) f g (Pre i l)" (*                                                                        *)
  proof (simp add: substitute'(2)) qed                                                              (*                                                                            *)
next                                                                                                (*  Holds for formulas within scope of existential quantification.            *)
  fix p e v t assume *: "semantics e' f g (sub v' t' p) = semantics (put e' v' (semantics_term e' f t')) f g p" for e' v' t' (*                                                   *)
  have "semantics e f g (sub v t (Exi p)) = (? x. semantics (put (put e 0 x) (v + 1) (semantics_term (put e 0 x) f (inc_term t))) f g p)" (*                                      *)
    using * proof simp qed                                                                          (*  Substitution within "Exi" can be obtained through "put" and "inc_term".   *)
  also have "... = (? x. semantics (put (put e v (semantics_term e f t)) 0 x) f g p)"               (*                                                                            *)
    using commute increment(1) proof metis qed                                                      (*  Using lemmas "commute" and "increment", we can reduce it to only "put".   *)
  finally show "semantics e f g (sub v t (Exi p)) = semantics (put e v (semantics_term e f t)) f g (Exi p)" proof simp qed (*                                                     *)
  have "semantics e f g (sub v t (Uni p)) = (! x. semantics (put (put e 0 x) (v + 1) (semantics_term (put e 0 x) f (inc_term t))) f g p)" (*                                      *)
    using * proof simp qed                                                                          (*  Holds for universal quantification. Same as for Exi p.                    *)
  also have "... = (! x. semantics (put (put e v (semantics_term e f t)) 0 x) f g p)"               (*                                                                            *)
    using commute increment(1) proof metis qed                                                      (*                                                                            *)
  finally show "semantics e f g (sub v t (Uni p)) = semantics (put e v (semantics_term e f t)) f g (Uni p)" proof simp qed (*                                                     *)
qed simp_all                                                                                        (*  The remaining cases are proved by simplification.                         *)
                                                                                                    (*                                                                            *)
lemma soundness': "OK p z ==> all (semantics e f g) z ==> semantics e f g p"                        (*  soundness': Proof rules are sound for arbitrary lists of assumptions.     *)
proof (induct arbitrary: f rule: OK.induct)                                                         (*  Proof by induction.                                                       *)
  fix f p z assume "all (semantics e f g) z"                                                        (*  Case: Boole.                                                              *)
      "all (semantics e f' g) (Imp p Falsity # z) ==> semantics e f' g Falsity" for f'              (*                                                                            *)
  then show "semantics e f g p" proof force qed                                                     (*                                                                            *)
next                                                                                                (*                                                                            *)
  fix f p q z r assume "all (semantics e f g) z"                                                    (*  Case: Disjunction Elimination.                                            *)
      "all (semantics e f' g) z ==> semantics e f' g (Dis p q)"                                     (*                                                                            *)
      "all (semantics e f' g) (p # z) ==> semantics e f' g r"                                       (*                                                                            *)
      "all (semantics e f' g) (q # z) ==> semantics e f' g r" for f'                                (*                                                                            *)
  then show "semantics e f g r" proof (simp, metis) qed                                             (*                                                                            *)
next                                                                                                (*                                                                            *)
  fix f p q z assume "all (semantics e f g) z"                                                      (*  Case: Conjunction Elimination.                                            *)
      "all (semantics e f' g) z ==> semantics e f' g (Con p q)" for f'                              (*                                                                            *)
  then show "semantics e f g p" "semantics e f g q" proof (simp, metis, simp, metis) qed            (*                                                                            *)
next                                                                                                (*                                                                            *)
  fix f p z q c assume *: "all (semantics e f g) z"                                                 (*  Case: Existential Elimination.                                            *)
      "all (semantics e f' g) z ==> semantics e f' g (Exi p)"                                       (*                                                                            *)
      "all (semantics e f' g) (sub 0 (Fun c []) p # z) ==> semantics e f' g q"                      (*                                                                            *)
      "news c (p # q # z)" for f'                                                                   (*                                                                            *)
  obtain x where "semantics (% n. if n = 0 then x else e (n - 1)) f g p"                            (*                                                                            *)
    using *(1) *(2) proof force qed                                                                 (*                                                                            *)
  then have "semantics (put e 0 x) f g p" proof simp qed                                            (*                                                                            *)
  then have "semantics (put e 0 x) (f(c := % w. x)) g p"                                            (*                                                                            *)
    using *(4) allhead allnew map proof blast qed                                                   (*                                                                            *)
  then have "semantics e (f(c := % w. x)) g (sub 0 (Fun c []) p)"                                   (*                                                                            *)
    proof (simp add: substitute) qed                                                                (*                                                                            *)
  moreover have "all (semantics e (f(c := % w. x)) g) z"                                            (*                                                                            *)
    using *(1) *(4) alltail allnew allmap proof blast qed                                           (*                                                                            *)
  ultimately have "semantics e (f(c := % w. x)) g q" using *(3) proof simp qed                      (*                                                                            *)
  then show "semantics e f g q" using *(4) allhead alltail allnew map proof blast qed               (*                                                                            *)
next                                                                                                (*                                                                            *)
  fix f z t p assume "all (semantics e f g) z"                                                      (*  Case: Existential Introduction.                                           *)
      "all (semantics e f' g) z ==> semantics e f' g (sub 0 t p)" for f'                            (*                                                                            *)
  then have "semantics (put e 0 (semantics_term e f t)) f g p" proof (simp add: substitute) qed     (*                                                                            *)
  then show "semantics e f g (Exi p)" proof (simp, metis) qed                                       (*                                                                            *)
next                                                                                                (*                                                                            *)
  fix f z t p assume "all (semantics e f g) z"                                                      (*  Case: Universal Elimination.                                              *)
      "all (semantics e f' g) z ==> semantics e f' g (Uni p)" for f'                                (*                                                                            *)
  then show "semantics e f g (sub 0 t p)" proof (simp add: substitute) qed                          (*                                                                            *)
next                                                                                                (*                                                                            *)
  fix f c p z assume *: "all (semantics e f g) z"                                                   (*  Case: Universal Introduction.                                             *)
      "all (semantics e f' g) z ==> semantics e f' g (sub 0 (Fun c []) p)"                          (*                                                                            *)
      "news c (p # z)" for f'                                                                       (*                                                                            *)
  have "semantics (% n. if n = 0 then x else e (n - 1)) f g p" for x                                (*                                                                            *)
  proof -                                                                                           (*                                                                            *)
    have "all (semantics e (f(c := % w. x)) g) z"                                                   (*                                                                            *)
      using *(1) *(3) alltail allnew allmap proof blast qed                                         (*                                                                            *)
    then have "semantics e (f(c := % w. x)) g (sub 0 (Fun c []) p)"                                 (*                                                                            *)
      using *(2) proof simp qed                                                                     (*                                                                            *)
    then have "semantics (% n. if n = 0 then x else e (n - 1)) (f(c := % w. x)) g p"                (*                                                                            *)
      proof (simp add: substitute) qed                                                              (*                                                                            *)
    then show "semantics (% n. if n = 0 then x else e (n - 1)) f g p"                               (*                                                                            *)
      using *(3) allhead alltail allnew map proof blast qed                                         (*                                                                            *)
  qed                                                                                               (*                                                                            *)
  then show "semantics e f g (Uni p)" proof simp qed                                                (*                                                                            *)
qed simp_all                                                                                        (*  The remaining cases are proved by simplification.                         *)
                                                                                                    (*                                                                            *)
theorem soundness: "OK p [] ==> semantics e f g p" proof (simp add: soundness') qed                 (*  soundness: Proof rules are sound starting from no assumptions.            *)
                                                                                                    (*             This is directly derived once soundness' is proved.            *)
corollary "? p. OK p []" "? p. ~ OK p []"                                                           (*                                                                            *)
proof -                                                                                             (*  Proof of consistency: Something, but not everything, can be proved.       *)
  have "OK (Imp p p) []" for p proof (rule Imp_I, rule Assume, simp) qed                            (*                                                                            *)
  then show "? p. OK p []" proof iprover qed                                                        (*                                                                            *)
next                                                                                                (*                                                                            *)
  have "~ semantics (e :: nat => unit) f g Falsity" for e f g proof simp qed                        (*                                                                            *)
  then show "? p. ~ OK p []" using soundness proof iprover qed                                      (*                                                                            *)
qed                                                                                                 (*                                                                            *)
                                                                                                    (*                                                                            *)
end                                                                                                 (*                                                                            *)
